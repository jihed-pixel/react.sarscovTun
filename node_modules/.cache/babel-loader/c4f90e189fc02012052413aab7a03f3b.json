{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _JSONArrow = _interopRequireDefault(require(\"./JSONArrow\"));\n\nvar _getCollectionEntries = _interopRequireDefault(require(\"./getCollectionEntries\"));\n\nvar _JSONNode = _interopRequireDefault(require(\"./JSONNode\"));\n\nvar _ItemRange = _interopRequireDefault(require(\"./ItemRange\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction isRange(rangeOrEntry) {\n  return rangeOrEntry.to !== undefined;\n}\n\nfunction renderChildNodes(props, from, to) {\n  var nodeType = props.nodeType,\n      data = props.data,\n      collectionLimit = props.collectionLimit,\n      circularCache = props.circularCache,\n      keyPath = props.keyPath,\n      postprocessValue = props.postprocessValue,\n      sortObjectKeys = props.sortObjectKeys;\n  var childNodes = [];\n  (0, _getCollectionEntries[\"default\"])(nodeType, data, sortObjectKeys, collectionLimit, from, to).forEach(function (entry) {\n    if (isRange(entry)) {\n      childNodes.push( /*#__PURE__*/_react[\"default\"].createElement(_ItemRange[\"default\"], _extends({}, props, {\n        key: \"ItemRange--\".concat(entry.from, \"-\").concat(entry.to),\n        from: entry.from,\n        to: entry.to,\n        renderChildNodes: renderChildNodes\n      })));\n    } else {\n      var key = entry.key,\n          value = entry.value;\n      var isCircular = circularCache.indexOf(value) !== -1;\n      childNodes.push( /*#__PURE__*/_react[\"default\"].createElement(_JSONNode[\"default\"], _extends({}, props, {\n        postprocessValue: postprocessValue,\n        collectionLimit: collectionLimit\n      }, {\n        key: \"Node--\".concat(key),\n        keyPath: [key].concat(_toConsumableArray(keyPath)),\n        value: postprocessValue(value),\n        circularCache: [].concat(_toConsumableArray(circularCache), [value]),\n        isCircular: isCircular,\n        hideRoot: false\n      })));\n    }\n  });\n  return childNodes;\n}\n\nfunction getStateFromProps(props) {\n  // calculate individual node expansion if necessary\n  var expanded = props.shouldExpandNode && !props.isCircular ? props.shouldExpandNode(props.keyPath, props.data, props.level) : false;\n  return {\n    expanded: expanded\n  };\n}\n\nvar JSONNestedNode = /*#__PURE__*/function (_React$Component) {\n  _inherits(JSONNestedNode, _React$Component);\n\n  var _super = _createSuper(JSONNestedNode);\n\n  function JSONNestedNode(props) {\n    var _this;\n\n    _classCallCheck(this, JSONNestedNode);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClick\", function () {\n      if (_this.props.expandable) {\n        _this.setState({\n          expanded: !_this.state.expanded\n        });\n      }\n    });\n\n    _this.state = getStateFromProps(props);\n    return _this;\n  }\n\n  _createClass(JSONNestedNode, [{\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      var nextState = getStateFromProps(nextProps);\n\n      if (getStateFromProps(this.props).expanded !== nextState.expanded) {\n        this.setState(nextState);\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var _this2 = this;\n\n      return !!Object.keys(nextProps).find(function (key) {\n        return key !== 'circularCache' && (key === 'keyPath' ? nextProps[key].join('/') !== _this2.props[key].join('/') : nextProps[key] !== _this2.props[key]);\n      }) || nextState.expanded !== this.state.expanded;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          getItemString = _this$props.getItemString,\n          nodeTypeIndicator = _this$props.nodeTypeIndicator,\n          nodeType = _this$props.nodeType,\n          data = _this$props.data,\n          hideRoot = _this$props.hideRoot,\n          createItemString = _this$props.createItemString,\n          styling = _this$props.styling,\n          collectionLimit = _this$props.collectionLimit,\n          keyPath = _this$props.keyPath,\n          labelRenderer = _this$props.labelRenderer,\n          expandable = _this$props.expandable;\n      var expanded = this.state.expanded;\n      var renderedChildren = expanded || hideRoot && this.props.level === 0 ? renderChildNodes(_objectSpread(_objectSpread({}, this.props), {}, {\n        level: this.props.level + 1\n      })) : null;\n\n      var itemType = /*#__PURE__*/_react[\"default\"].createElement(\"span\", styling('nestedNodeItemType', expanded), nodeTypeIndicator);\n\n      var renderedItemString = getItemString(nodeType, data, itemType, createItemString(data, collectionLimit));\n      var stylingArgs = [keyPath, nodeType, expanded, expandable];\n      return hideRoot ? /*#__PURE__*/_react[\"default\"].createElement(\"li\", styling.apply(void 0, ['rootNode'].concat(stylingArgs)), /*#__PURE__*/_react[\"default\"].createElement(\"ul\", styling.apply(void 0, ['rootNodeChildren'].concat(stylingArgs)), renderedChildren)) : /*#__PURE__*/_react[\"default\"].createElement(\"li\", styling.apply(void 0, ['nestedNode'].concat(stylingArgs)), expandable && /*#__PURE__*/_react[\"default\"].createElement(_JSONArrow[\"default\"], {\n        styling: styling,\n        nodeType: nodeType,\n        expanded: expanded,\n        onClick: this.handleClick\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"label\", _extends({}, styling.apply(void 0, [['label', 'nestedNodeLabel']].concat(stylingArgs)), {\n        onClick: this.handleClick\n      }), labelRenderer.apply(void 0, stylingArgs)), /*#__PURE__*/_react[\"default\"].createElement(\"span\", _extends({}, styling.apply(void 0, ['nestedNodeItemString'].concat(stylingArgs)), {\n        onClick: this.handleClick\n      }), renderedItemString), /*#__PURE__*/_react[\"default\"].createElement(\"ul\", styling.apply(void 0, ['nestedNodeChildren'].concat(stylingArgs)), renderedChildren));\n    }\n  }]);\n\n  return JSONNestedNode;\n}(_react[\"default\"].Component);\n\nexports[\"default\"] = JSONNestedNode;\n\n_defineProperty(JSONNestedNode, \"propTypes\", {\n  getItemString: _propTypes[\"default\"].func.isRequired,\n  nodeTypeIndicator: _propTypes[\"default\"].any,\n  nodeType: _propTypes[\"default\"].string.isRequired,\n  data: _propTypes[\"default\"].any,\n  hideRoot: _propTypes[\"default\"].bool.isRequired,\n  createItemString: _propTypes[\"default\"].func.isRequired,\n  styling: _propTypes[\"default\"].func.isRequired,\n  collectionLimit: _propTypes[\"default\"].number,\n  keyPath: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].oneOfType([_propTypes[\"default\"].string, _propTypes[\"default\"].number])).isRequired,\n  labelRenderer: _propTypes[\"default\"].func.isRequired,\n  shouldExpandNode: _propTypes[\"default\"].func,\n  level: _propTypes[\"default\"].number.isRequired,\n  sortObjectKeys: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].func, _propTypes[\"default\"].bool]),\n  isCircular: _propTypes[\"default\"].bool,\n  expandable: _propTypes[\"default\"].bool\n});\n\n_defineProperty(JSONNestedNode, \"defaultProps\", {\n  data: [],\n  circularCache: [],\n  level: 0,\n  expandable: true\n});","map":{"version":3,"sources":["../src/JSONNestedNode.tsx"],"names":["rangeOrEntry","nodeType","data","collectionLimit","circularCache","keyPath","postprocessValue","sortObjectKeys","props","childNodes","isRange","entry","renderChildNodes","key","value","isCircular","expanded","JSONNestedNode","React","Component","getItemString","PropTypes","nodeTypeIndicator","hideRoot","createItemString","styling","labelRenderer","shouldExpandNode","level","expandable","bool","getStateFromProps","nextProps","nextState","renderedChildren","itemType","renderedItemString","stylingArgs","handleClick"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport JSONArrow from './JSONArrow';\nimport getCollectionEntries from './getCollectionEntries';\nimport JSONNode from './JSONNode';\nimport ItemRange from './ItemRange';\nimport {\n  CircularPropsPassedThroughJSONNestedNode,\n  CircularPropsPassedThroughRenderChildNodes,\n} from './types';\n\n/**\n * Renders nested values (eg. objects, arrays, lists, etc.)\n */\n\nexport interface RenderChildNodesProps\n  extends CircularPropsPassedThroughRenderChildNodes {\n  data: any;\n  nodeType: string;\n}\n\ninterface Range {\n  from: number;\n  to: number;\n}\n\ninterface Entry {\n  key: string | number;\n  value: any;\n}\n\nfunction isRange(rangeOrEntry: Range | Entry): rangeOrEntry is Range {\n  return (rangeOrEntry as Range).to !== undefined;\n}\n\nfunction renderChildNodes(\n  props: RenderChildNodesProps,\n  from?: number,\n  to?: number\n) {\n  const {\n    nodeType,\n    data,\n    collectionLimit,\n    circularCache,\n    keyPath,\n    postprocessValue,\n    sortObjectKeys,\n  } = props;\n  const childNodes: React.ReactNode[] = [];\n\n  getCollectionEntries(\n    nodeType,\n    data,\n    sortObjectKeys,\n    collectionLimit,\n    from,\n    to\n  ).forEach((entry) => {\n    if (isRange(entry)) {\n      childNodes.push(\n        <ItemRange\n          {...props}\n          key={`ItemRange--${entry.from}-${entry.to}`}\n          from={entry.from}\n          to={entry.to}\n          renderChildNodes={renderChildNodes}\n        />\n      );\n    } else {\n      const { key, value } = entry;\n      const isCircular = circularCache.indexOf(value) !== -1;\n\n      childNodes.push(\n        <JSONNode\n          {...props}\n          {...{ postprocessValue, collectionLimit }}\n          key={`Node--${key}`}\n          keyPath={[key, ...keyPath]}\n          value={postprocessValue(value)}\n          circularCache={[...circularCache, value]}\n          isCircular={isCircular}\n          hideRoot={false}\n        />\n      );\n    }\n  });\n\n  return childNodes;\n}\n\ninterface Props extends CircularPropsPassedThroughJSONNestedNode {\n  data: any;\n  nodeType: string;\n  nodeTypeIndicator: string;\n  createItemString: (data: any, collectionLimit: number) => string;\n  expandable: boolean;\n}\n\ninterface State {\n  expanded: boolean;\n}\n\nfunction getStateFromProps(props: Props) {\n  // calculate individual node expansion if necessary\n  const expanded =\n    props.shouldExpandNode && !props.isCircular\n      ? props.shouldExpandNode(props.keyPath, props.data, props.level)\n      : false;\n  return {\n    expanded,\n  };\n}\n\nexport default class JSONNestedNode extends React.Component<Props, State> {\n  static propTypes = {\n    getItemString: PropTypes.func.isRequired,\n    nodeTypeIndicator: PropTypes.any,\n    nodeType: PropTypes.string.isRequired,\n    data: PropTypes.any,\n    hideRoot: PropTypes.bool.isRequired,\n    createItemString: PropTypes.func.isRequired,\n    styling: PropTypes.func.isRequired,\n    collectionLimit: PropTypes.number,\n    keyPath: PropTypes.arrayOf(\n      PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n    ).isRequired,\n    labelRenderer: PropTypes.func.isRequired,\n    shouldExpandNode: PropTypes.func,\n    level: PropTypes.number.isRequired,\n    sortObjectKeys: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n    isCircular: PropTypes.bool,\n    expandable: PropTypes.bool,\n  };\n\n  static defaultProps = {\n    data: [],\n    circularCache: [],\n    level: 0,\n    expandable: true,\n  };\n\n  constructor(props: Props) {\n    super(props);\n    this.state = getStateFromProps(props);\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\n    const nextState = getStateFromProps(nextProps);\n    if (getStateFromProps(this.props).expanded !== nextState.expanded) {\n      this.setState(nextState);\n    }\n  }\n\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    return (\n      !!Object.keys(nextProps).find(\n        (key) =>\n          key !== 'circularCache' &&\n          (key === 'keyPath'\n            ? nextProps[key].join('/') !== this.props[key].join('/')\n            : nextProps[key as keyof Props] !== this.props[key as keyof Props])\n      ) || nextState.expanded !== this.state.expanded\n    );\n  }\n\n  render() {\n    const {\n      getItemString,\n      nodeTypeIndicator,\n      nodeType,\n      data,\n      hideRoot,\n      createItemString,\n      styling,\n      collectionLimit,\n      keyPath,\n      labelRenderer,\n      expandable,\n    } = this.props;\n    const { expanded } = this.state;\n    const renderedChildren =\n      expanded || (hideRoot && this.props.level === 0)\n        ? renderChildNodes({ ...this.props, level: this.props.level + 1 })\n        : null;\n\n    const itemType = (\n      <span {...styling('nestedNodeItemType', expanded)}>\n        {nodeTypeIndicator}\n      </span>\n    );\n    const renderedItemString = getItemString(\n      nodeType,\n      data,\n      itemType,\n      createItemString(data, collectionLimit)\n    );\n    const stylingArgs = [keyPath, nodeType, expanded, expandable] as const;\n\n    return hideRoot ? (\n      <li {...styling('rootNode', ...stylingArgs)}>\n        <ul {...styling('rootNodeChildren', ...stylingArgs)}>\n          {renderedChildren}\n        </ul>\n      </li>\n    ) : (\n      <li {...styling('nestedNode', ...stylingArgs)}>\n        {expandable && (\n          <JSONArrow\n            styling={styling}\n            nodeType={nodeType}\n            expanded={expanded}\n            onClick={this.handleClick}\n          />\n        )}\n        <label\n          {...styling(['label', 'nestedNodeLabel'], ...stylingArgs)}\n          onClick={this.handleClick}\n        >\n          {labelRenderer(...stylingArgs)}\n        </label>\n        <span\n          {...styling('nestedNodeItemString', ...stylingArgs)}\n          onClick={this.handleClick}\n        >\n          {renderedItemString}\n        </span>\n        <ul {...styling('nestedNodeChildren', ...stylingArgs)}>\n          {renderedChildren}\n        </ul>\n      </li>\n    );\n  }\n\n  handleClick = () => {\n    if (this.props.expandable) {\n      this.setState({ expanded: !this.state.expanded });\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}