{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = getCollectionEntries;\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction getLength(type, collection) {\n  if (type === 'Object') {\n    return Object.keys(collection).length;\n  } else if (type === 'Array') {\n    return collection.length;\n  }\n\n  return Infinity;\n}\n\nfunction isIterableMap(collection) {\n  return typeof collection.set === 'function';\n}\n\nfunction getEntries(type, collection, sortObjectKeys) {\n  var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n  var res;\n\n  if (type === 'Object') {\n    var keys = Object.getOwnPropertyNames(collection);\n\n    if (sortObjectKeys) {\n      keys.sort(sortObjectKeys === true ? undefined : sortObjectKeys);\n    }\n\n    keys = keys.slice(from, to + 1);\n    res = {\n      entries: keys.map(function (key) {\n        return {\n          key: key,\n          value: collection[key]\n        };\n      })\n    };\n  } else if (type === 'Array') {\n    res = {\n      entries: collection.slice(from, to + 1).map(function (val, idx) {\n        return {\n          key: idx + from,\n          value: val\n        };\n      })\n    };\n  } else {\n    var idx = 0;\n    var entries = [];\n    var done = true;\n    var isMap = isIterableMap(collection);\n\n    var _iterator = _createForOfIteratorHelper(collection),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n\n        if (idx > to) {\n          done = false;\n          break;\n        }\n\n        if (from <= idx) {\n          if (isMap && Array.isArray(item)) {\n            if (typeof item[0] === 'string' || typeof item[0] === 'number') {\n              entries.push({\n                key: item[0],\n                value: item[1]\n              });\n            } else {\n              entries.push({\n                key: \"[entry \".concat(idx, \"]\"),\n                value: {\n                  '[key]': item[0],\n                  '[value]': item[1]\n                }\n              });\n            }\n          } else {\n            entries.push({\n              key: idx,\n              value: item\n            });\n          }\n        }\n\n        idx++;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    res = {\n      hasMore: !done,\n      entries: entries\n    };\n  }\n\n  return res;\n}\n\nfunction getRanges(from, to, limit) {\n  var ranges = [];\n\n  while (to - from > limit * limit) {\n    limit = limit * limit;\n  }\n\n  for (var i = from; i <= to; i += limit) {\n    ranges.push({\n      from: i,\n      to: Math.min(to, i + limit - 1)\n    });\n  }\n\n  return ranges;\n}\n\nfunction getCollectionEntries(type, collection, sortObjectKeys, limit) {\n  var from = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var to = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n  var getEntriesBound = getEntries.bind(null, type, collection, sortObjectKeys);\n\n  if (!limit) {\n    return getEntriesBound().entries;\n  }\n\n  var isSubset = to < Infinity;\n  var length = Math.min(to - from, getLength(type, collection));\n\n  if (type !== 'Iterable') {\n    if (length <= limit || limit < 7) {\n      return getEntriesBound(from, to).entries;\n    }\n  } else {\n    if (length <= limit && !isSubset) {\n      return getEntriesBound(from, to).entries;\n    }\n  }\n\n  var limitedEntries;\n\n  if (type === 'Iterable') {\n    var _getEntriesBound = getEntriesBound(from, from + limit - 1),\n        hasMore = _getEntriesBound.hasMore,\n        entries = _getEntriesBound.entries;\n\n    limitedEntries = hasMore ? [].concat(_toConsumableArray(entries), _toConsumableArray(getRanges(from + limit, from + 2 * limit - 1, limit))) : entries;\n  } else {\n    limitedEntries = isSubset ? getRanges(from, to, limit) : [].concat(_toConsumableArray(getEntriesBound(0, limit - 5).entries), _toConsumableArray(getRanges(limit - 4, length - 5, limit)), _toConsumableArray(getEntriesBound(length - 4, length - 1).entries));\n  }\n\n  return limitedEntries;\n}","map":{"version":3,"sources":["../src/getCollectionEntries.ts"],"names":["type","Object","collection","from","to","Infinity","keys","sortObjectKeys","res","entries","key","value","idx","val","done","isMap","isIterableMap","item","Array","hasMore","ranges","limit","i","Math","getEntriesBound","getEntries","isSubset","length","getLength","limitedEntries","getRanges"],"mappings":"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","sourcesContent":["function getLength(type: string, collection: any) {\n  if (type === 'Object') {\n    return Object.keys(collection).length;\n  } else if (type === 'Array') {\n    return (collection as unknown[]).length;\n  }\n\n  return Infinity;\n}\n\nfunction isIterableMap(collection: any) {\n  return typeof (collection as Map<any, any>).set === 'function';\n}\n\nfunction getEntries(\n  type: string,\n  collection: any,\n  sortObjectKeys?: ((a: any, b: any) => number) | boolean | undefined,\n  from = 0,\n  to = Infinity\n): { entries: { key: string | number; value: any }[]; hasMore?: boolean } {\n  let res;\n\n  if (type === 'Object') {\n    let keys = Object.getOwnPropertyNames(collection);\n\n    if (sortObjectKeys) {\n      keys.sort(sortObjectKeys === true ? undefined : sortObjectKeys);\n    }\n\n    keys = keys.slice(from, to + 1);\n\n    res = {\n      entries: keys.map((key) => ({ key, value: collection[key] })),\n    };\n  } else if (type === 'Array') {\n    res = {\n      entries: collection\n        .slice(from, to + 1)\n        .map((val: unknown, idx: number) => ({ key: idx + from, value: val })),\n    };\n  } else {\n    let idx = 0;\n    const entries = [];\n    let done = true;\n\n    const isMap = isIterableMap(collection);\n\n    for (const item of collection) {\n      if (idx > to) {\n        done = false;\n        break;\n      }\n      if (from <= idx) {\n        if (isMap && Array.isArray(item)) {\n          if (typeof item[0] === 'string' || typeof item[0] === 'number') {\n            entries.push({ key: item[0], value: item[1] });\n          } else {\n            entries.push({\n              key: `[entry ${idx}]`,\n              value: {\n                '[key]': item[0],\n                '[value]': item[1],\n              },\n            });\n          }\n        } else {\n          entries.push({ key: idx, value: item });\n        }\n      }\n      idx++;\n    }\n\n    res = {\n      hasMore: !done,\n      entries,\n    };\n  }\n\n  return res;\n}\n\nfunction getRanges(from: number, to: number, limit: number) {\n  const ranges = [];\n  while (to - from > limit * limit) {\n    limit = limit * limit;\n  }\n  for (let i = from; i <= to; i += limit) {\n    ranges.push({ from: i, to: Math.min(to, i + limit - 1) });\n  }\n\n  return ranges;\n}\n\nexport default function getCollectionEntries(\n  type: string,\n  collection: any,\n  sortObjectKeys: ((a: any, b: any) => number) | boolean | undefined,\n  limit: number,\n  from = 0,\n  to = Infinity\n) {\n  const getEntriesBound = getEntries.bind(\n    null,\n    type,\n    collection,\n    sortObjectKeys\n  );\n\n  if (!limit) {\n    return getEntriesBound().entries;\n  }\n\n  const isSubset = to < Infinity;\n  const length = Math.min(to - from, getLength(type, collection));\n\n  if (type !== 'Iterable') {\n    if (length <= limit || limit < 7) {\n      return getEntriesBound(from, to).entries;\n    }\n  } else {\n    if (length <= limit && !isSubset) {\n      return getEntriesBound(from, to).entries;\n    }\n  }\n\n  let limitedEntries;\n  if (type === 'Iterable') {\n    const { hasMore, entries } = getEntriesBound(from, from + limit - 1);\n\n    limitedEntries = hasMore\n      ? [...entries, ...getRanges(from + limit, from + 2 * limit - 1, limit)]\n      : entries;\n  } else {\n    limitedEntries = isSubset\n      ? getRanges(from, to, limit)\n      : [\n          ...getEntriesBound(0, limit - 5).entries,\n          ...getRanges(limit - 4, length - 5, limit),\n          ...getEntriesBound(length - 4, length - 1).entries,\n        ];\n  }\n\n  return limitedEntries;\n}\n"]},"metadata":{},"sourceType":"script"}